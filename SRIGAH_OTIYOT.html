<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hebrew Alphabet Connection Map</title>
<style>
  :root{
    --bg:#0b0f14;
    --panel:#121820;
    --ink:#e6edf3;
    --muted:#9fb0c3;
    --accent:#5cd3ff;
    --accent2:#8fff7a;
    --edge:#67a0ff;
    --edge-dim:#274264;
    --edge-strong:#ffb86b;
    --warn:#f6c177;
    --ring:#ffd166;
    --focus:#ff8e3c;
	--incoming:#ff57e2;
  }

  html,body{height:100%}
  body{
    margin:0;
    background:linear-gradient(180deg,#0b0f14 0%, #0d1320 100%);
    color:var(--ink);
    font:16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Cantarell, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
    display:flex; flex-direction:column; gap:0.75rem;
  }

  header{
    background:var(--panel);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.04), 0 6px 20px rgba(0,0,0,0.3);
    position:sticky; top:0; z-index:5;
  }

  .toolbar{
    display:flex; flex-wrap:wrap; gap:.75rem 1rem; align-items: end;
    padding: .85rem clamp(.75rem, 2vw, 1.25rem);
    max-width:1200px; margin-inline:auto;
  }

  .control{
    display:grid; gap:.35rem;
    min-width: clamp(180px, 24vw, 320px);
  }
  .control.small{ min-width: 160px; }
  label{font-weight:600; color:var(--muted); letter-spacing:.02em; font-size:.9rem}
  select, input[type="text"], button{
    background:#0e1522; border:1px solid #203146;
    color:var(--ink);
    padding:.55rem .65rem; border-radius:.6rem;
    outline:none;
    transition:border-color .15s ease, box-shadow .15s ease;
  }
  select:focus, input[type="text"]:focus, button:focus{
    border-color:var(--focus);
    box-shadow:0 0 0 3px color-mix(in oklab, var(--focus) 30%, transparent);
  }

  .row{
    display:flex; align-items:center; gap:.5rem; flex-wrap:wrap;
  }

  .toggle-group{
    background:#0e1522; border:1px solid #203146; border-radius:.6rem;
    padding: .25rem; display:inline-flex; gap:.25rem;
  }
  .toggle-group button{
    background:transparent; border:0; padding:.4rem .65rem; border-radius:.45rem;
    color:var(--muted); cursor:pointer; font-weight:600;
  }
  .toggle-group button[aria-pressed="true"]{
    background:linear-gradient(180deg, #16314e, #0e2035);
    color:var(--ink);
    border:1px solid #3a7bd5;
  }

  .legend{
    display:flex; align-items:center; gap:.75rem; flex-wrap:wrap; color:var(--muted);
  }
  .chip{display:inline-flex; align-items:center; gap:.4rem}
  .chip .dot{width:14px; height:6px; border-radius:2px; display:inline-block}
  .edge-default{ background: var(--edge); }
  .edge-strong{ background: var(--edge-strong); }
  .edge-dim{ background: var(--edge-dim); }
  .ring{ width:12px; height:12px; border:3px solid var(--ring); border-radius:50%}

  main{ flex:1; display:grid; place-items:center; padding: .5rem 0 1.25rem }
  .stage-wrap{ width:min(1200px, 96vw); aspect-ratio: 1.7/1; }
  svg{ width:100%; height:100%; display:block; }

  /* Node styles */
  .node-group{ cursor:pointer; }
  .node-circle{
    fill:#0e1420;
    stroke:#23344a;
    stroke-width:1.5;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,.25));
    transition: transform .15s ease, filter .15s ease, stroke .15s ease;
  }
  .node-letter{
    font-family: "Noto Sans Hebrew", "Rubik", "David Libre", Arial, sans-serif;
    font-size: clamp(22px, 3.2vw, 42px);
    fill:var(--ink);
    pointer-events:none;
  }
  .node-label{
    font-size: .78rem;
    fill: var(--muted);
    opacity:0;
    transform: translateY(-6px);
    transition: opacity .18s ease, transform .18s ease;
    pointer-events:none;
  }
  .node-group:hover .node-label,
  .node-group:focus-visible .node-label{ opacity:1; transform: translateY(-2px); }

  .node-group:hover .node-circle{ stroke:#3a7bd5; filter:drop-shadow(0 6px 14px rgba(40,120,255,.25)); }
  .node-group:focus-visible .node-circle{ stroke:var(--focus); filter: drop-shadow(0 0 0 rgba(0,0,0,0)); }
  .node-ring{ fill:none; stroke:transparent; stroke-width:4; }
  .node-ring.highlight{ stroke:var(--ring); stroke-width:5; filter: drop-shadow(0 0 12px rgba(255,209,102,.35)); }

  /* Edges */
  .edge{
    fill:none;
    stroke:var(--edge);
    stroke-width:2.2;
    opacity:.9;
    filter: drop-shadow(0 4px 8px rgba(20,40,90,.25));
    stroke-linecap:round;
    stroke-dasharray:1 9999; /* will be overridden per-path for animation */
    stroke-dashoffset:1;
  }
  .edge.dim{ stroke:var(--edge-dim); opacity:.45; }
  .edge.strong{ stroke:var(--edge-strong); opacity:1; stroke-width:3; filter: drop-shadow(0 6px 12px rgba(255,184,107,.25)); }
  .edge.emph{ stroke:var(--accent2); stroke-width:3; filter: drop-shadow(0 6px 12px rgba(143,255,122,.3)); }
  .edge.incoming{
    stroke: var(--incoming);
    stroke-width: 3;
    opacity: 1;
    filter: drop-shadow(0 6px 12px rgba(255,87,226,.35));
  }

  .hidden{ display:none; }
  .faint{ opacity:.25 }

  .sr-only{
    position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0;
  }

  .footer-note{
    color:var(--muted); font-size:.85rem; text-align:center; padding-bottom:1rem;
  }

  /* Responsive tweaks */
  @media (max-width:720px){
    .control{ min-width: 100%; }
    .stage-wrap{ aspect-ratio: 1/1; }
  }
</style>
</head>
<body>
  <header>
    <form class="toolbar" id="controls" aria-describedby="status">
      <div class="control">
        <label for="selectLetter">Show connections for:</label>
        <select id="selectLetter" aria-label="Choose a letter to show its connections">
          <option value="">— Select a letter —</option>
        </select>
      </div>
		<div class="control small">
			<label id="showModeLbl">Show:</label>
				<div class="toggle-group" role="group" aria-labelledby="showModeLbl">
				<button type="button" id="modeSelected" aria-pressed="true">Selected Letter</button>
				<button type="button" id="modeAll" aria-pressed="false">All Letters</button>
			</div>
		</div>
      <div class="control small">
  <div class="row" style="gap:.35rem">
    <div>
      <label for="toggleOutgoing">Outgoing:</label>
      <div class="toggle-group" role="group" aria-label="Toggle outgoing connections">
        <button type="button" id="toggleOutgoing" aria-pressed="true">On</button>
        <button type="button" id="toggleOutgoingOff" aria-pressed="false">Off</button>
      </div>
    </div>
    <div>
      <label for="toggleIncoming">Incoming:</label>
      <div class="toggle-group" role="group" aria-label="Toggle incoming connections">
        <button type="button" id="toggleIncoming" aria-pressed="false">On</button>
        <button type="button" id="toggleIncomingOff" aria-pressed="true">Off</button>
      </div>
    </div>
  </div>
</div>

      <div class="control" dir="rtl">
        <label for="wordInput">Highlight letters in word:</label>
        <input id="wordInput" type="text" inputmode="text" autocomplete="off"
               placeholder="הקלד/י מילה בעברית…" aria-describedby="wordHelp" />
        <div id="wordHelp" class="sr-only">Type a Hebrew word. Niqqud is ignored. Final forms normalize to base letters.</div>
      </div>

      <div class="row" style="margin-left:auto">
        <div class="legend" aria-hidden="true">
          <span class="chip"><span class="dot edge-default"></span>connection</span>
          <span class="chip"><span class="dot edge-strong"></span>selected</span>
          <span class="chip"><span class="dot edge-dim"></span>dimmed</span>
          <span class="chip"><span class="ring"></span>letter in word</span>
        </div>
        <button type="button" id="resetBtn" title="Reset filters and view">Reset</button>
      </div>

      <div class="sr-only" aria-live="polite" id="status">Ready.</div>
    </form>
  </header>

  <main>
    <div class="stage-wrap">
      <svg id="stage" viewBox="-600 -400 1200 800" role="img" aria-labelledby="title desc">
        <title id="title">Hebrew Alphabet Connection Map</title>
        <desc id="desc">Nodes are Hebrew letters arranged around a circle. Lines indicate letters used to spell each letter’s name.</desc>

        <!-- Circle guide (faint) -->
        <g opacity=".08">
          <circle cx="0" cy="0" r="310" fill="none" stroke="white" stroke-width="1"/>
        </g>

        <!-- Edges go here -->
        <g id="edgeLayer"></g>

        <!-- Nodes go here; lang=he for correct shaping/semantics -->
        <g id="nodeLayer" lang="he"></g>
      </svg>
    </div>
  </main>

  <div class="footer-note">
    Tip: switch to “All Letters” and hover a node to emphasize its own connections.
  </div>

<script>
/* ========= Data Model =========
   All metadata lives here for easy editing.
   - key: base Hebrew letter (no niqqud, non-final form)
   - nameLat: Latin name
   - nameHe: Hebrew spelling of the letter name (use base forms; niqqud omitted)
*/
const LETTERS = [
  { he:'א', nameLat:'Aleph',  nameHe:'אלף'   },
  { he:'ב', nameLat:'Bet',    nameHe:'בית'   },
  { he:'ג', nameLat:'Gimel',  nameHe:'גימל'  },
  { he:'ד', nameLat:'Dalet',  nameHe:'דלת'   },
  { he:'ה', nameLat:'He',     nameHe:'הא'    },
  { he:'ו', nameLat:'Vav',    nameHe:'וו'    },
  { he:'ז', nameLat:'Zayin',  nameHe:'זין'   },
  { he:'ח', nameLat:'Het',    nameHe:'חית'   },
  { he:'ט', nameLat:'Tet',    nameHe:'טית'   },
  { he:'י', nameLat:'Yod',    nameHe:'יוד'   },
  { he:'כ', nameLat:'Kaf',    nameHe:'כף'    },
  { he:'ל', nameLat:'Lamed',  nameHe:'למד'   },
  { he:'מ', nameLat:'Mem',    nameHe:'מם'    },
  { he:'נ', nameLat:'Nun',    nameHe:'נון'   },
  { he:'ס', nameLat:'Samekh', nameHe:'סמך'   },
  { he:'ע', nameLat:'Ayin',   nameHe:'עין'   },
  { he:'פ', nameLat:'Pe',     nameHe:'פה'    },
  { he:'צ', nameLat:'Tsadi',  nameHe:'צדי'   },
  { he:'ק', nameLat:'Qof',    nameHe:'קוף'   },
  { he:'ר', nameLat:'Resh',   nameHe:'ריש'   },
  { he:'ש', nameLat:'Shin',   nameHe:'שין'   },
  { he:'ת', nameLat:'Tav',    nameHe:'תיו'   },
];

/* ========= Utilities ========= */
const FINAL_MAP = { 'ך':'כ','ם':'מ','ן':'נ','ף':'פ','ץ':'צ' };
const HEBREW_NIQQUD_RE = /[\u0591-\u05BD\u05BF-\u05C7]/g;
const NON_LETTERS_RE = /[^א-ת]/g;

function normalizeHebrew(s=''){
  return s.replace(HEBREW_NIQQUD_RE,'')
          .split('')
          .map(ch => FINAL_MAP[ch] || ch)
          .join('')
          .replace(NON_LETTERS_RE,'');
}

const byHe = new Map(LETTERS.map(L => [L.he, L]));
const idxByHe = new Map(LETTERS.map((L,i)=>[L.he,i]));

/* Build connections: for each letter, list of constituent letters (normalized) */
const CONNECTIONS = {};
for(const L of LETTERS){
  const seq = normalizeHebrew(L.nameHe).split('');
  CONNECTIONS[L.he] = seq;
}

/* ========= Layout ========= */
const RADIUS = 310; // circle radius in SVG units
const CENTER = {x:0, y:0};

const stage = document.getElementById('stage');
const nodeLayer = document.getElementById('nodeLayer');
const edgeLayer = document.getElementById('edgeLayer');
const selectLetter = document.getElementById('selectLetter');
const wordInput = document.getElementById('wordInput');
const modeSelectedBtn = document.getElementById('modeSelected');
const modeAllBtn = document.getElementById('modeAll');
const resetBtn = document.getElementById('resetBtn');
const statusLive = document.getElementById('status');

let showMode = 'selected'; // 'selected' | 'all'
let selectedHe = '';
let wordLetters = new Set();
let hoverHe = ''; // currently hovered node (for emphasis in All mode)
let showOutgoing = true;  // default On
let showIncoming = false; // default Off

/* Populate select options */
for(const L of LETTERS){
  const opt = document.createElement('option');
  opt.value = L.he;
  opt.textContent = `${L.nameLat} ${L.he}`;
  selectLetter.appendChild(opt);
}

/* Compute positions around the circle */
const positions = LETTERS.map((L,i)=>{
  const angle = (i / LETTERS.length) * Math.PI * 2 - Math.PI/2; // start at top
  return {
    he:L.he,
    x: CENTER.x + RADIUS * Math.cos(angle),
    y: CENTER.y + RADIUS * Math.sin(angle),
    angle
  };
});
const posByHe = new Map(positions.map(p => [p.he, p]));

/* ========= Draw Nodes ========= */
function createNode(L){
  const p = posByHe.get(L.he);
  const g = document.createElementNS('http://www.w3.org/2000/svg','g');
  g.classList.add('node-group');
  g.setAttribute('transform', `translate(${p.x}, ${p.y})`);
  g.setAttribute('tabindex', '0');
  g.setAttribute('role', 'button');
  g.setAttribute('data-he', L.he);
  g.setAttribute('aria-pressed', 'false');
  g.setAttribute('aria-label', `${L.nameLat} (${L.he})`);

  const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
  circle.setAttribute('r','26');
  circle.setAttribute('class','node-circle');
  g.appendChild(circle);

  const ring = document.createElementNS('http://www.w3.org/2000/svg','circle');
  ring.setAttribute('r','32');
  ring.setAttribute('class','node-ring');
  g.appendChild(ring);

  const text = document.createElementNS('http://www.w3.org/2000/svg','text');
  text.setAttribute('class','node-letter');
  text.setAttribute('text-anchor','middle');
  text.setAttribute('dominant-baseline','central');
  text.setAttribute('y','2');
  text.textContent = L.he;
  g.appendChild(text);

  const label = document.createElementNS('http://www.w3.org/2000/svg','text');
  label.setAttribute('class','node-label');
  label.setAttribute('text-anchor','middle');
  label.setAttribute('y','-40');
  label.textContent = L.nameLat;
  g.appendChild(label);

  // hover/focus emphasis for "All Letters" mode
  g.addEventListener('mouseenter', () => { hoverHe = L.he; refreshEdges(); });
  g.addEventListener('mouseleave', () => { hoverHe = ''; refreshEdges(); });
  g.addEventListener('click', () => { selectLetter.value = L.he; selectedHe = L.he; showMode='selected'; syncModeButtons(); announce(`Showing connections for ${L.nameLat}`); refresh(); });
  g.addEventListener('keydown', (e)=>{
    if(e.key==='Enter' || e.key===' '){
      e.preventDefault(); g.click();
    }
  });

  nodeLayer.appendChild(g);
}
LETTERS.forEach(createNode);

/* ========= Draw Edges =========
   We pre-create an SVG path for each possible directed pair that occurs (letter -> each constituent).
   In "selected" mode we toggle visibility; in "all" mode we show all.
*/
const edgePaths = []; // items: { from, to, path }
function pathId(f,t){ return `e_${idxByHe.get(f)}_${idxByHe.get(t)}`; }

function makeCurve(p1, p2, bias=0.18, jitter=0){ // Quadratic Bezier control point
  const mx = (p1.x + p2.x)/2;
  const my = (p1.y + p2.y)/2;
  // perpendicular offset for slight curve + jitter
  const dx = p2.x - p1.x, dy = p2.y - p1.y;
  const len = Math.hypot(dx, dy) || 1;
  const nx = -dy/len, ny = dx/len;
  const cx = mx + nx * len * bias + nx * jitter;
  const cy = my + ny * len * bias + ny * jitter;
  return `M ${p1.x} ${p1.y} Q ${cx} ${cy} ${p2.x} ${p2.y}`;
}

// Gather all unique edges (with multiplicity for jitter when overlapping)
const edgeCount = new Map(); // key "from->to" => count so far
for(const L of LETTERS){
  const from = L.he;
  for(const to of CONNECTIONS[from]){
    if(!byHe.has(to)) continue;
    const key = `${from}->${to}`;
    const n = (edgeCount.get(key) || 0);
    edgeCount.set(key, n+1);

    const p1 = posByHe.get(from), p2 = posByHe.get(to);
    const jitter = (n % 3 - 1) * 6; // -6,0,6 cycling to separate overlaps
    const d = makeCurve(p1, p2, 0.18, jitter);

    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('class','edge');
    path.setAttribute('id', pathId(from,to)+'_'+n);
    path.setAttribute('data-from', from);
    path.setAttribute('data-to', to);
    path.setAttribute('d', d);
    edgeLayer.appendChild(path);
    edgePaths.push({from, to, path});
  }
}

/* ========= Interaction Logic ========= */
function syncModeButtons(){
  const sel = (showMode==='selected');
  modeSelectedBtn.setAttribute('aria-pressed', String(sel));
  modeAllBtn.setAttribute('aria-pressed', String(!sel));

  if(sel){
    // Keep select enabled
    selectLetter.disabled = false;
  }else{
    selectLetter.disabled = false; // allow still choosing for hover aria, but it's not filtering
  }
}

modeSelectedBtn.addEventListener('click', ()=>{ showMode='selected'; syncModeButtons(); announce('Showing selected letter connections.'); refresh(); });
modeAllBtn.addEventListener('click', ()=>{ showMode='all'; syncModeButtons(); announce('Showing all letter connections.'); refresh(); });

const toggleOutgoingOn  = document.getElementById('toggleOutgoing');
const toggleOutgoingOff = document.getElementById('toggleOutgoingOff');
const toggleIncomingOn  = document.getElementById('toggleIncoming');
const toggleIncomingOff = document.getElementById('toggleIncomingOff');

function setTogglePair(onBtn, offBtn, isOn){
  onBtn.setAttribute('aria-pressed', String(isOn));
  offBtn.setAttribute('aria-pressed', String(!isOn));
}

function syncInOutToggles(){
  setTogglePair(toggleOutgoingOn, toggleOutgoingOff, showOutgoing);
  setTogglePair(toggleIncomingOn, toggleIncomingOff, showIncoming);
}

toggleOutgoingOn.addEventListener('click', ()=>{
  showOutgoing = true; syncInOutToggles(); refresh();
});
toggleOutgoingOff.addEventListener('click', ()=>{
  showOutgoing = false; syncInOutToggles(); refresh();
});

toggleIncomingOn.addEventListener('click', ()=>{
  showIncoming = true; syncInOutToggles(); refresh();
});
toggleIncomingOff.addEventListener('click', ()=>{
  showIncoming = false; syncInOutToggles(); refresh();
});

// call once on load
syncInOutToggles();

selectLetter.addEventListener('change', (e)=>{
  selectedHe = e.target.value || '';
  const L = byHe.get(selectedHe);
  if(L){ announce(`Showing connections for ${L.nameLat}`); }
  refresh();
});

wordInput.addEventListener('input', ()=>{
  const norm = normalizeHebrew(wordInput.value);
  wordLetters = new Set(norm.split(''));
  refreshNodesHighlight();
  refreshEdges();
});

resetBtn.addEventListener('click', ()=>{
  selectLetter.value = '';
  selectedHe = '';
  wordInput.value = '';
  wordLetters.clear();
  showMode = 'selected';
  showOutgoing = true;   // default
  showIncoming = false;  // default
  syncModeButtons();
  syncInOutToggles();    // PATCH: reset toggles
  hoverHe = '';
  announce('Reset. No connections selected.');
  refresh();
});

function announce(msg){
  statusLive.textContent = msg;
}

/* Node highlighting based on word input & selected letter state */
function refreshNodesHighlight(){
  for(const g of nodeLayer.querySelectorAll('.node-group')){
    const he = g.getAttribute('data-he');
    const ring = g.querySelector('.node-ring');
    const inWord = wordLetters.has(he);
    ring.classList.toggle('highlight', inWord);

    // Dim others if in "selected" mode and a selection is active
    const dim = (showMode==='selected' && selectedHe && he !== selectedHe);
    g.style.opacity = dim ? .45 : 1;

    // Helpful aria for selected node
    if(he === selectedHe && showMode==='selected'){
      const targets = (CONNECTIONS[he]||[]).map(h=>byHe.get(h)?.nameLat).filter(Boolean);
      const aria = `${byHe.get(he).nameLat} (${he}), shows connections to: ${targets.join(', ') || '—'}`;
      g.setAttribute('aria-label', aria);
      g.setAttribute('aria-pressed','true');
    }else{
      g.setAttribute('aria-pressed','false');
      g.setAttribute('aria-label', `${byHe.get(he).nameLat} (${he})`);
    }
  }
}

/* Edge rendering rules */
function refreshEdges(){
  const showAll = (showMode === 'all');
  const sel = selectedHe;

  // Build incoming set (selected excluded) — keep this in sync with the block above if you moved it.
  const incomingFromSet = new Set();
  if (showIncoming && sel) {
    for (const l of LETTERS) {
      if (l.he === sel) continue;
      const seq = CONNECTIONS[l.he] || [];
      if (seq.includes(sel)) incomingFromSet.add(l.he);
    }
  }

  for (const { from, to, path } of edgePaths) {
    let visible = false;
    const cls = ['edge'];

    const isOutgoingFromSelected = !!(sel && from === sel);
    const isIncomingEdge         = incomingFromSet.has(from);
    const isFromWordLetter       = wordLetters.has(from);
    const isToWordLetter         = wordLetters.has(to);

    if (showAll) {
      // Visibility
      visible = showOutgoing ? true : isIncomingEdge;

      // Coloring precedence: incoming (magenta) > outgoing-selected (orange) > word/hover
      if (isIncomingEdge) {
        cls.push('incoming');              // magenta
      } else if (showOutgoing && isOutgoingFromSelected) {
        cls.push('strong');                // orange
      } else if (showOutgoing && (isFromWordLetter || isToWordLetter)) {
        cls.push('emph');                  // green accent
      }

      // Hover only affects non-incoming and only when outgoing is on
      if (hoverHe && showOutgoing && !isIncomingEdge) {
        if (from === hoverHe) cls.push('emph'); else cls.push('dim');
      }

      if (!visible) cls.push('dim');

    } else {
      // Selected mode
      const showIncomingOnly     = isIncomingEdge && showIncoming;
      const showOutgoingSelected = isOutgoingFromSelected && showOutgoing;
      const showWordOut          = showOutgoing && isFromWordLetter; // gated by outgoing

      visible = showIncomingOnly || showOutgoingSelected || showWordOut;

      if (showIncomingOnly) {
        cls.push('incoming');              // magenta
      } else if (showOutgoingSelected) {
        cls.push('strong');                // orange
      } else if (showWordOut) {
        cls.push('emph');                  // green accent
      }

      if (!visible) cls.push('dim');
    }

    // Apply + animate
    path.className.baseVal = cls.join(' ');
    path.style.display = visible ? 'inline' : 'none';

    if (visible) {
      const len = path.getTotalLength();
      path.style.strokeDasharray = `${len} ${len}`;
      path.style.strokeDashoffset = len;
      void path.getBoundingClientRect();
      path.style.transition = 'stroke-dashoffset 400ms ease';
      path.style.strokeDashoffset = '0';
    } else {
      path.style.transition = 'none';
    }
  }
}

/* Full refresh */
function refresh(){
  refreshNodesHighlight();
  refreshEdges();
}
syncModeButtons();
refresh();

/* ====== Initial ARIA announcement when user selects via keyboard ====== */
stage.addEventListener('focusin', (e)=>{
  const g = e.target.closest?.('.node-group');
  if(g){
    const he = g.getAttribute('data-he');
    const L = byHe.get(he);
    announce(`${L.nameLat} selected. Press Enter to show its connections.`);
  }
});

/* ========= Nice extras: click on background to clear hover in "All" ========= */
stage.addEventListener('click', (e)=>{
  if(e.target === stage){
    hoverHe = '';
    refreshEdges();
  }
});

/* ========= Populate subtle tooltips via <title> on each node ========= */
for(const g of nodeLayer.querySelectorAll('.node-group')){
  const he = g.getAttribute('data-he');
  const L = byHe.get(he);
  const t = document.createElementNS('http://www.w3.org/2000/svg','title');
  t.textContent = `${L.nameLat} — ${L.nameHe}`;
  g.appendChild(t);
}

/* ========= Keyboard navigation: simple left/right on ring ========= */
document.addEventListener('keydown', (e)=>{
  const active = document.activeElement;
  if(!active?.classList?.contains('node-group')) return;
  const curHe = active.getAttribute('data-he');
  const idx = idxByHe.get(curHe);
  if(e.key==='ArrowRight' || e.key==='ArrowDown'){
    e.preventDefault();
    const next = (idx + 1) % LETTERS.length;
    focusNode(next);
  }else if(e.key==='ArrowLeft' || e.key==='ArrowUp'){
    e.preventDefault();
    const prev = (idx - 1 + LETTERS.length) % LETTERS.length;
    focusNode(prev);
  }
});
function focusNode(i){
  const he = LETTERS[i].he;
  const el = nodeLayer.querySelector(`.node-group[data-he="${he}"]`);
  el?.focus();
}
</script>
</body>
</html>
